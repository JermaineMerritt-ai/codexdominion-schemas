#!/usr/bin/env python3
"""
ðŸ“š Codex Tome Formatter
======================

Convert Codex notebook JSON files to beautifully formatted Markdown documents.
Part of the Codex Dominion Suite Cycle 1.

Usage:
    python codex_tome_formatter.py [input_file] [output_file]
    python codex_tome_formatter.py --batch [input_directory] [output_directory]

Features:
    - Convert individual notebook JSON files to Markdown
    - Batch processing of multiple notebooks
    - Handle text, code, and prompt cell types
    - Include metadata and proper formatting
    - Error handling and validation
"""

import json
import os
import sys
from datetime import datetime
from pathlib import Path


def format_tome(notebook_file="notebook.json", output_file="tome.md"):
    """
    Convert a Codex notebook JSON file to a formatted Markdown document.

    Args:
        notebook_file (str): Path to the input JSON notebook file
        output_file (str): Path to the output Markdown file

    Returns:
        bool: True if conversion successful, False otherwise
    """
    try:
        # Read the notebook JSON file
        with open(notebook_file, "r", encoding="utf-8") as f:
            data = json.load(f)

        # Create the output directory if it doesn't exist
        output_path = Path(output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Write the formatted Markdown
        with open(output_file, "w", encoding="utf-8") as f:
            # Write header with metadata
            f.write("# ðŸ“š Codex Tome\n\n")

            # Add metadata if available
            if "metadata" in data:
                metadata = data["metadata"]
                f.write("## Document Information\n\n")
                f.write(f"- **Name**: {metadata.get('name', 'Unknown')}\n")
                f.write(
                    f"- **Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
                )
                f.write(
                    f"- **Cell Count**: {metadata.get('cell_count', len(data.get('cells', [])))}\n"
                )
                f.write(f"- **Version**: {metadata.get('codex_version', '1.0')}\n\n")
                f.write("---\n\n")

            # Process each cell
            cells = data.get("cells", [])
            for i, cell in enumerate(cells):
                cell_number = i + 1

                if cell["type"] == "text":
                    f.write(f"## ðŸ“ Text Cell {cell_number}\n\n")
                    f.write(f"{cell['content']}\n\n")

                elif cell["type"] == "code":
                    f.write(f"## ðŸ’» Code Cell {cell_number}\n\n")
                    f.write(f"```python\n{cell['content']}\n```\n\n")

                elif cell["type"] == "prompt":
                    f.write(f"## ðŸ¤– Prompt Cell {cell_number}\n\n")
                    f.write(f"> **Prompt**: {cell['content']}\n\n")

                # Add separator between cells
                if cell_number < len(cells):
                    f.write("---\n\n")

            # Add footer
            f.write("---\n\n")
            f.write(
                "*Generated by Codex Tome Formatter - Part of the Codex Dominion Suite*\n"
            )

        print(f"âœ… Successfully converted {notebook_file} to {output_file}")
        return True

    except FileNotFoundError:
        print(f"âŒ Error: Could not find file {notebook_file}")
        return False
    except json.JSONDecodeError as e:
        print(f"âŒ Error: Invalid JSON format in {notebook_file}: {e}")
        return False
    except Exception as e:
        print(f"âŒ Error: {e}")
        return False


def batch_format_tomes(input_directory, output_directory):
    """
    Process multiple notebook JSON files in a directory

    Args:
        input_directory (str): Directory containing JSON notebook files
        output_directory (str): Directory to save Markdown tomes

    Returns:
        dict: Summary of processing results
    """
    results = {"success": 0, "failed": 0, "files": []}

    # Ensure output directory exists
    Path(output_directory).mkdir(parents=True, exist_ok=True)

    # Find all JSON files in input directory
    input_path = Path(input_directory)
    json_files = list(input_path.glob("*.json"))

    if not json_files:
        print(f"âš ï¸ No JSON files found in {input_directory}")
        return results

    print(f"ðŸ“ Found {len(json_files)} JSON files to process")

    for json_file in json_files:
        # Generate output filename
        output_file = Path(output_directory) / f"{json_file.stem}_tome.md"

        # Process the file
        if format_tome(str(json_file), str(output_file)):
            results["success"] += 1
            results["files"].append(
                {
                    "input": str(json_file),
                    "output": str(output_file),
                    "status": "success",
                }
            )
        else:
            results["failed"] += 1
            results["files"].append(
                {
                    "input": str(json_file),
                    "output": str(output_file),
                    "status": "failed",
                }
            )

    print(f"\nðŸ“Š Batch Processing Results:")
    print(f"âœ… Successfully processed: {results['success']}")
    print(f"âŒ Failed to process: {results['failed']}")

    return results


def main():
    """Main function for command-line usage"""

    print("ðŸ“š Codex Tome Formatter - Codex Dominion Suite v1.0")
    print("=" * 60)

    if len(sys.argv) < 2:
        # Default behavior - look for notebook.json in current directory
        if os.path.exists("notebook.json"):
            print("ðŸ” Found notebook.json in current directory")
            format_tome("notebook.json", "tome.md")
        else:
            print("ðŸ“– Usage Examples:")
            print("  python codex_tome_formatter.py input.json output.md")
            print("  python codex_tome_formatter.py --batch input_dir output_dir")
            print("\nðŸ’¡ Or place a 'notebook.json' file in the current directory")
            return

    # Handle batch processing
    if sys.argv[1] == "--batch":
        if len(sys.argv) >= 4:
            input_dir = sys.argv[2]
            output_dir = sys.argv[3]
            batch_format_tomes(input_dir, output_dir)
        else:
            print("âŒ Batch mode requires input and output directories")
            print(
                "   Usage: python codex_tome_formatter.py --batch input_dir output_dir"
            )

    # Handle single file processing
    elif len(sys.argv) >= 3:
        input_file = sys.argv[1]
        output_file = sys.argv[2]
        format_tome(input_file, output_file)

    else:
        input_file = sys.argv[1]
        # Generate output filename
        output_file = Path(input_file).stem + "_tome.md"
        format_tome(input_file, output_file)


def create_sample_notebook():
    """Create a sample notebook for testing"""
    sample_data = {
        "metadata": {
            "name": "sample_codex_notebook",
            "created_at": datetime.now().isoformat(),
            "cell_count": 3,
            "codex_version": "1.0",
            "notebook_type": "codex_interactive",
        },
        "cells": [
            {
                "type": "text",
                "content": "# Sample Codex Notebook\n\nThis is a demonstration of the **Codex Tome Formatter**.",
                "created_at": datetime.now().isoformat(),
            },
            {
                "type": "code",
                "content": "print('Hello, Codex Dominion!')\nx = 42\nprint(f'The answer is {x}')",
                "created_at": datetime.now().isoformat(),
            },
            {
                "type": "prompt",
                "content": "Explain the significance of the number 42 in science fiction.",
                "created_at": datetime.now().isoformat(),
            },
        ],
    }

    with open("sample_notebook.json", "w", encoding="utf-8") as f:
        json.dump(sample_data, f, indent=4, ensure_ascii=False)

    print("ðŸ“„ Created sample_notebook.json")
    return sample_data


if __name__ == "__main__":
    # Integration with Codex Suite
    try:
        # Try to add to ledger if available
        import os
        import sys

        sys.path.append(os.path.join(os.path.dirname(__file__), "..", ".."))
        from core.ledger import append_entry

        append_entry(
            "ledger.json",
            "entries",
            {
                "role": "TomeFormatter",
                "proclamation": "Codex Tome Formatter activated - Converting notebooks to eternal markdown wisdom",
                "type": "system_activation",
            },
        )
    except ImportError:
        pass  # Ledger integration optional

    main()
